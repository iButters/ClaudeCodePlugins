# Vulnerability Patterns - Top 5 in LLM-Generated Code

**Used By**:
- `agents/security-evaluator.md` (CWE-89, CWE-78, CWE-22, CWE-338, CWE-327 detection)
- `skills/plugin-reviewer/SKILL.md` (Security constraints and safe coding examples)

---

LLM-generated code shows recurring security weaknesses. These five patterns appear most frequently and should be checked in every code review.

## 1. SQL Injection (CWE-89) - Frequency: 35-40%

### Vulnerable Pattern
```python
# Dangerous - string interpolation
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)

# Dangerous - string concatenation
name = request.form['name']
query = "SELECT * FROM users WHERE name = '" + name + "'"
```

### Secure Mitigation
```python
# Safe - parameterized query
user_id = request.args.get('id')
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

# Safe - named parameters (SQLAlchemy)
from sqlalchemy import text
stmt = text("SELECT * FROM users WHERE name = :name")
result = conn.execute(stmt, {"name": name})
```

### Red Flags
- String formatting (`f"..."`, `.format()`, `+`) inside SQL queries
- User input directly in the query string
- Missing input validation

## 2. Command Injection (CWE-78) - Frequency: 25-30%

### Vulnerable Pattern
```python
# Dangerous - shell command with user input
filename = request.args.get('file')
os.system(f"cat {filename}")

# Dangerous - shell=True with user input
subprocess.run(f"convert {user_file} output.png", shell=True)
```

### Secure Mitigation
```python
# Safe - subprocess without shell
filename = request.args.get('file')
subprocess.run(["cat", filename], check=True)

# Safe - input validation + whitelist
import re
if re.match(r'^[a-zA-Z0-9_-]+\.txt$', filename):
    subprocess.run(["cat", filename], check=True)
else:
    raise ValueError("Invalid filename")
```

### Red Flags
- `os.system()` with user input
- `subprocess.run(..., shell=True)` with user input
- String concatenation of system commands

## 3. Path Traversal (CWE-22) - Frequency: 15-20%

### Vulnerable Pattern
```python
# Dangerous - direct file access
user_path = request.args.get('file')
with open(f"/data/{user_path}", 'r') as f:
    content = f.read()

# Dangerous - no canonicalization check
filepath = os.path.join('/uploads', user_filename)
```

### Secure Mitigation
```python
# Safe - path validation with resolve()
from pathlib import Path

base_dir = Path("/data")
user_path = request.args.get('file')
full_path = (base_dir / user_path).resolve()

# Ensure the resolved path stays within base_dir
if base_dir in full_path.parents:
    with open(full_path, 'r') as f:
        content = f.read()
else:
    raise ValueError("Path traversal detected")
```

### Red Flags
- Directly opening files using user input in the path
- No validation against `../` sequences
- Missing canonicalization checks

## 4. Weak Random (CWE-338) - Frequency: 10-15%

### Vulnerable Pattern
```python
# Dangerous - random for security
import random
session_token = ''.join(random.choices('0123456789abcdef', k=32))

# Dangerous - time-based seed
random.seed(int(time.time()))
api_key = random.randint(100000, 999999)
```

### Secure Mitigation
```python
# Safe - secrets module
import secrets
session_token = secrets.token_hex(32)  # 64 hex chars
api_key = secrets.token_urlsafe(32)    # URL-safe token

# Safe - cryptographically secure random
secure_random = secrets.randbelow(900000) + 100000  # 6-digit number
```

### Red Flags
- Using the `random` module for security-critical values
- Tokens, API keys, session IDs generated with `random`
- Not using the `secrets` module

## 5. Weak Cryptography (CWE-327) - Frequency: 5-10%

### Vulnerable Pattern
```python
# Dangerous - MD5 for passwords
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()

# Dangerous - SHA1 for passwords
password_hash = hashlib.sha1(password.encode()).hexdigest()

# Dangerous - simple hashing without salt
password_hash = hashlib.sha256(password.encode()).hexdigest()
```

### Secure Mitigation
```python
# Safe - bcrypt with automatic salt
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

# Verification
if bcrypt.checkpw(password.encode(), stored_hash):
    print("Login successful")

# Safe - Argon2 (modern alternative)
from argon2 import PasswordHasher
ph = PasswordHasher()
password_hash = ph.hash(password)
```

### Red Flags
- MD5 or SHA1 for password hashing
- No salt for password hashing
- Not using bcrypt, scrypt, or Argon2

## Mitigation Effectiveness

| Strategy                                   | Vulnerability Reduction |
|--------------------------------------------|-------------------------|
| Explicit security instructions in prompt   | +15-20%                 |
| Example-based teaching (secure code examples) | +10-15%              |
| Multiple verification passes               | +20-25%                 |
| Security-focused system prompt             | +56%                    |
| **Combined approach**                      | **~70-80%**             |

## Security Checklist for Code Review

```markdown
[ ] SQL queries use parameterized statements (no string interpolation)
[ ] System commands use subprocess lists instead of shell=True
[ ] File operations validate paths against a base directory
[ ] Security-related random values use secrets instead of random
[ ] Passwords are hashed with bcrypt/scrypt/argon2 (not MD5/SHA1)
[ ] User input is validated before processing
[ ] Sensitive data (API keys, passwords) is not hardcoded
[ ] Error messages do not leak implementation details
```

## Quick Fix Patterns

**SQL Injection:** `str.format()` / f-strings -> `cursor.execute(query, params)`  
**Command Injection:** `os.system()` -> `subprocess.run([...], check=True)`  
**Path Traversal:** `open(user_path)` -> `Path(user_path).resolve()` + validation  
**Weak Random:** `random` -> `secrets`  
**Weak Crypto:** `hashlib.md5()` -> `bcrypt.hashpw()`
